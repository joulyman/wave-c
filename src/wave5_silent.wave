# ğŸŒŠ Wave 5.0 é™é»˜ç¼–è¯‘å™¨
# â•â•â• unified.wave â•â•â•
# ğŸŒŒ Wave ç»Ÿä¸€åœº (Unified Field)
# è§„åˆ™æ˜ å°„å±‚ï¼šæŠŠè®¡ç®—æœºè¡Œä¸ºæ˜ å°„ä¸ºç‰©ç†æ•°å­¦è§„åˆ™

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ ¸å¿ƒï¼šç»Ÿä¸€åœºæ˜¯è§„åˆ™çš„æºå¤´
# è®¡ç®—æœºçš„æ‰€æœ‰è¡Œä¸ºï¼ˆCPUã€å†…å­˜ã€IOï¼‰éƒ½å¯ä»¥ç”¨è¿™äº›è§„åˆ™æè¿°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ç»Ÿä¸€åœºä¸‰å‚æ•° â€” æè¿°ä»»ä½•è®¡ç®—æœºè¡Œä¸º
unified {
    information_density: 1.0    # ä¿¡æ¯å¯†åº¦ï¼šæ•°æ®ç´§å‡‘ç¨‹åº¦
    entropy_gradient: 0.0       # ç†µæ¢¯åº¦ï¼šæ— åºåº¦å˜åŒ–
    relation_strength: 1.0      # å…³ç³»å¼ºåº¦ï¼šå…ƒç´ å…³è”ç¨‹åº¦
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ´¾ç”Ÿè§„åˆ™ â€” ä»ä¸‰å‚æ•°æ´¾ç”Ÿçš„ç‰©ç†æ•°å­¦è§„åˆ™
# è¿™äº›è§„åˆ™æè¿°è®¡ç®—æœºçš„å„ç§è¡Œä¸ºæ¨¡å¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å¼•åŠ›è§„åˆ™ â€” æè¿°æ•°æ®èšåˆè¡Œä¸º
# ä¾‹ï¼šç¼“å­˜å±€éƒ¨æ€§ã€å†…å­˜æ± èšåˆ
fn derive.gravitational {
        strength: unified.information_density
        inverse_square: 2.0 * unified.entropy_gradient + 1.0
        threshold: unified.relation_strength * 0.1
    }
}

# å¼ åŠ›è§„åˆ™ â€” æè¿°èµ„æºå‹åŠ›è¡Œä¸º
# ä¾‹ï¼šå†…å­˜å‹åŠ›ã€CPU è´Ÿè½½
fn derive.tension {
        base: unified.relation_strength
        accumulation: unified.entropy_gradient
        release: unified.information_density * 0.8
    }
}

# ç†µè§„åˆ™ â€” æè¿°æ— åºåº¦å˜åŒ–
# ä¾‹ï¼šå†…å­˜ç¢ç‰‡ã€æ•°æ®éšæœºæ€§
fn derive.entropy {
        initial: unified.entropy_gradient
        growth: unified.information_density * 0.01
        critical: 1.0 - unified.relation_strength * 0.1
    }
}

# è¿æ¥è§„åˆ™ â€” æè¿°å…ƒç´ å…³è”è¡Œä¸º
# ä¾‹ï¼šæŒ‡é’ˆå…³ç³»ã€æ•°æ®ç»“æ„è¿æ¥
fn derive.connection {
        strength: unified.relation_strength
        plasticity: unified.entropy_gradient
        decay: 1.0 - unified.information_density
    }
}

# è®°å¿†è§„åˆ™ â€” æè¿°æŒä¹…æ€§è¡Œä¸º
# ä¾‹ï¼šç¼“å­˜ä¿æŒã€çŠ¶æ€æŒä¹…
fn derive.memory {
        persistence: unified.information_density
        recall: unified.relation_strength
        decay: unified.entropy_gradient * 0.001
    }
}

# è½¨é“è§„åˆ™ â€” æè¿°å¾ªç¯è¡Œä¸º
# ä¾‹ï¼šä»»åŠ¡è°ƒåº¦ã€åŠ¨ç”»å¾ªç¯
fn derive.orbital {
        eccentricity: unified.entropy_gradient
        period: unified.relation_strength
        stability: unified.information_density
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™æ˜ å°„ â€” æŠŠé«˜çº§æ¦‚å¿µæ˜ å°„åˆ°è§„åˆ™ç»„åˆ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# æ˜ å°„ï¼šç¼“å­˜è¡Œä¸º
rule map.cache {
    gravitational.strength = 0.9    # é«˜èšåˆ
    memory.persistence = 0.9        # é«˜æŒä¹…
    entropy.growth = 0.1            # ä½ç¢ç‰‡
}

# æ˜ å°„ï¼šæµå¼å¤„ç†
rule map.stream {
    entropy.growth = 0.8            # å¿«é€ŸæµåŠ¨
    connection.plasticity = 0.3     # ä½å…³è”
    memory.persistence = 0.2        # ä½æŒä¹…
}

# æ˜ å°„ï¼šå›¾ç»“æ„
rule map.graph {
    connection.strength = 0.9       # é«˜è¿æ¥
    relation_strength = 0.9         # é«˜å…³è”
    gravitational.strength = 0.5    # ä¸­ç­‰èšåˆ
}

# æ˜ å°„ï¼šå¹¶è¡Œè®¡ç®—
rule map.parallel {
    orbital.period = 0.1            # å¿«é€Ÿå¾ªç¯
    entropy.growth = 0.5            # ä¸­ç­‰æ— åº
    connection.plasticity = 0.7     # é«˜å¯å¡‘
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆå§‹åŒ–å’ŒæŠ¥å‘Š
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn unified.init {
    unified.information_density = 1.0
    unified.entropy_gradient = 0.0
    unified.relation_strength = 1.0
}

fn unified.report {
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åŠ¨æ€è°ƒæ•´ â€” è¿è¡Œæ—¶æ ¹æ®è§‚æµ‹è°ƒæ•´å‚æ•°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn unified.adjust usage fragmentation patterns {
    when usage > 80 {
        unified.entropy_gradient = unified.entropy_gradient + 0.1
    }
    when fragmentation > 50 {
        unified.information_density = unified.information_density + 0.1
    }
    when patterns > 0 {
        unified.relation_strength = unified.relation_strength + 0.1
    }
    
    # å½’ä¸€åŒ–
    when unified.information_density > 1.0 { unified.information_density = 1.0 }
    when unified.entropy_gradient > 1.0 { unified.entropy_gradient = 1.0 }
    when unified.relation_strength > 1.0 { unified.relation_strength = 1.0 }
}

# â•â•â• tile.wave â•â•â•
# ğŸ§± Tile å†…å­˜ç®¡ç†å™¨
# å®é™…çš„å†…å­˜åˆ†é…å’Œç®¡ç†

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å››å…ƒå†…å­˜æ±  (TileQuattro)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å†…å­˜æ± å®šä¹‰
pool BlackHole {
    base: 0x10000
    size: 65536
    used: 0
    purpose: "compression"    # å‹ç¼©å­˜å‚¨
}

pool MeshBrain {
    base: 0x20000
    size: 65536
    used: 0
    purpose: "pattern"        # æ¨¡å¼å¤„ç†
}

pool MultiNova {
    base: 0x30000
    size: 65536
    used: 0
    purpose: "parallel"       # å¹¶è¡Œæ•°æ®
}

pool BaseForce {
    base: 0x40000
    size: 65536
    used: 0
    purpose: "fragment"       # å¿«é€Ÿç¢ç‰‡
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å†…å­˜åˆ†é… â€” æ ¹æ®ç»Ÿä¸€åœºè§„åˆ™é€‰æ‹©æ± 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.alloc size {
    # æ ¹æ®å½“å‰ç»Ÿä¸€åœºå‚æ•°é€‰æ‹©æœ€ä½³æ± 
    
    # é«˜ä¿¡æ¯å¯†åº¦ â†’ BlackHole (å‹ç¼©)
    when unified.information_density > 0.8 {
    }
    
    # é«˜å…³ç³»å¼ºåº¦ â†’ MeshBrain (æ¨¡å¼)
    when unified.relation_strength > 0.8 {
    }
    
    # é«˜ç†µæ¢¯åº¦ â†’ BaseForce (å¿«é€Ÿ)
    when unified.entropy_gradient > 0.5 {
    }
    
    # é»˜è®¤ â†’ MultiNova (é€šç”¨)
}

fn tile.alloc_from pool size {
    when pool.used + size > pool.size {
        # æ± æ»¡ï¼Œè§¦å‘æ”¶ç¼©
        tile.compact(pool)
    }
    
    addr = pool.base + pool.used
    pool.used = pool.used + size
    
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å†…å­˜é‡Šæ”¾
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.free addr size {
    # ç¡®å®šå±äºå“ªä¸ªæ± 
    when addr >= BlackHole.base {
        when addr < BlackHole.base + BlackHole.size {
            BlackHole.used = BlackHole.used - size
            return
        }
    }
    when addr >= MeshBrain.base {
        when addr < MeshBrain.base + MeshBrain.size {
            MeshBrain.used = MeshBrain.used - size
            return
        }
    }
    when addr >= MultiNova.base {
        when addr < MultiNova.base + MultiNova.size {
            MultiNova.used = MultiNova.used - size
            return
        }
    }
    when addr >= BaseForce.base {
        when addr < BaseForce.base + BaseForce.size {
            BaseForce.used = BaseForce.used - size
            return
        }
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å†…å­˜ç´§ç¼© (Collapse è§¦å‘)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.compact pool {
    # ç´§ç¼©å†…å­˜ï¼Œå‡å°‘ç¢ç‰‡
    # Collapse è¾¹é™…æ”¶ç›Šæ£€æŸ¥
    
    before = pool.used
    # ... æ‰§è¡Œç´§ç¼© ...
    after = pool.used
    
    gain = before - after
    
    # è¾¹é™…æ”¶ç›Šæ£€æŸ¥
    when gain < pool.size * 0.05 {
        # æ”¶ç›Šå¤ªå°ï¼Œåœæ­¢
        return
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ± çŠ¶æ€æŠ¥å‘Š
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.report {
}

fn tile.total_used {
}

fn tile.total_size {
}

fn tile.fragmentation {
    # è®¡ç®—ç¢ç‰‡ç‡
    total = tile.total_size()
    used = tile.total_used()
    
    # ç®€åŒ–ï¼šå‡è®¾ç¢ç‰‡ = åˆ†æ•£ç¨‹åº¦
    pools_active = 0
    when BlackHole.used > 0 { pools_active = pools_active + 1 }
    when MeshBrain.used > 0 { pools_active = pools_active + 1 }
    when MultiNova.used > 0 { pools_active = pools_active + 1 }
    when BaseForce.used > 0 { pools_active = pools_active + 1 }
    
    when pools_active <= 1 { -> 0 }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆå§‹åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.init {
    BlackHole.used = 0
    MeshBrain.used = 0
    MultiNova.used = 0
    BaseForce.used = 0
}

# â•â•â• fate.wave â•â•â•
# ğŸŒŠ Fate è°ƒåº¦å™¨
# å…¨å±€èµ„æºè°ƒåº¦ï¼Œè¿æ¥ç»Ÿä¸€åœºå’Œ Tile
#
# Wave åŒæ¨¡å¼ï¼š
#   - ä¸åŠ è½½ Fate â†’ é™æ€ä»£ç ï¼ˆç›´æ¥æ‰§è¡Œï¼Œæ— ä¼˜åŒ–ï¼‰
#   - åŠ è½½ Fate   â†’ åŠ¨æ€ä¼˜åŒ–ï¼ˆè‡ªåŠ¨åŒå‘ä¼˜åŒ–ï¼‰
#
# åŒå‘ä¼˜åŒ–ï¼š
#   - é€‚åº”ä»»åŠ¡ï¼šæ ¹æ®ä»£ç æ‰§è¡Œæ¨¡å¼è°ƒæ•´
#   - é€‚åº”ç¡¬ä»¶ï¼šæ ¹æ®ç¡¬ä»¶èƒ½åŠ›è°ƒæ•´
#
# Collapseï¼šè¾¾åˆ°ç¨³å®šçŠ¶æ€åï¼ŒåŠ¨æ€ä»£ç  â†’ é™æ€åŒ–


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Fate çŠ¶æ€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fate {
    enabled: true         # Fate æ˜¯å¦å¯ç”¨
    current_usage: 0
    peak_usage: 0
    resource_limit: 100
    collapse_count: 0
    strategy: 2           # 1=é«˜æ€§èƒ½, 2=æ ‡å‡†, 3=å…¼å®¹
    mode: "dynamic"       # "static" or "dynamic"
}

# ä»»åŠ¡ç‰¹å¾ï¼ˆé€‚åº”ä»»åŠ¡ï¼‰
task {
    compute_heavy: false   # è®¡ç®—å¯†é›†
    memory_heavy: false    # å†…å­˜å¯†é›†
    io_heavy: false        # IO å¯†é›†
    pattern_count: 0       # æ£€æµ‹åˆ°çš„æ¨¡å¼æ•°
    loop_count: 0          # å¾ªç¯æ¬¡æ•°
    branch_ratio: 0.0      # åˆ†æ”¯æ¯”ä¾‹
}

# GPU èƒ½åŠ›
gpu {
    vendor: 0
    vram: 0
    max_w: 1920
    max_h: 1080
    ready: false
}

# æ€§èƒ½ç›‘æ§
perf {
    frame_count: 0
    frame_time: 0
    fps: 60
    frame_start: 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# èµ„æºåˆ†é… â€” é€šè¿‡ Tile ç®¡ç†å™¨
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.allocate size {
    # é€šè¿‡ Tile åˆ†é…å†…å­˜
    addr = tile.alloc(size)
    
    # æ›´æ–°ä½¿ç”¨ç»Ÿè®¡
    fate.current_usage = tile.total_used() * 100 / tile.total_size()
    
    when fate.current_usage > fate.peak_usage {
        fate.peak_usage = fate.current_usage
    }
    
    # æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒæ•´ç»Ÿä¸€åœº
    fate.check_adjust()
    
}

fn fate.release addr size {
    tile.free(addr, size)
    fate.current_usage = tile.total_used() * 100 / tile.total_size()
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# é€‚åº”ä»»åŠ¡ â€” æ ¹æ®ä»£ç æ‰§è¡Œæ¨¡å¼è°ƒæ•´
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.observe_task {
    # ç›‘æ§ä»£ç æ‰§è¡Œï¼Œè¯†åˆ«ä»»åŠ¡ç‰¹å¾
    
    # æ£€æµ‹è®¡ç®—å¯†é›†
    when perf.fps < 30 {
        when fate.current_usage < 50 {
            task.compute_heavy = true
        }
    }
    
    # æ£€æµ‹å†…å­˜å¯†é›†
    when fate.current_usage > 70 {
        task.memory_heavy = true
    }
    
    # æ£€æµ‹ IO å¯†é›†
    when perf.frame_time > 16 {
        when fate.current_usage < 30 {
            task.io_heavy = true
        }
    }
}

fn fate.adapt_to_task {
    # æ ¹æ®ä»»åŠ¡ç‰¹å¾è°ƒæ•´ç»Ÿä¸€åœºå‚æ•°
    
    when task.compute_heavy {
        # è®¡ç®—å¯†é›†ï¼šå¢åŠ ä¿¡æ¯å¯†åº¦ï¼Œä¼˜åŒ–ç¼“å­˜
        unified.information_density = 0.9
        unified.relation_strength = 0.8
    }
    
    when task.memory_heavy {
        # å†…å­˜å¯†é›†ï¼šå¢åŠ ç†µæ¢¯åº¦ï¼Œå¿«é€Ÿåˆ†é…é‡Šæ”¾
        unified.entropy_gradient = 0.7
    }
    
    when task.io_heavy {
        # IO å¯†é›†ï¼šå¹³è¡¡å‚æ•°
        unified.information_density = 0.5
        unified.entropy_gradient = 0.5
        unified.relation_strength = 0.5
    }
    
    when task.pattern_count > 5 {
        # æ£€æµ‹åˆ°æ¨¡å¼ï¼šå¢åŠ å…³ç³»å¼ºåº¦
        unified.relation_strength = 0.9
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# é€‚åº”ç¡¬ä»¶ â€” å·²æœ‰ GPU é€‚åº”ï¼Œè¡¥å……é€šç”¨ç¡¬ä»¶
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.adapt_to_hardware {
    # GPU é€‚åº”ï¼ˆå·²å®ç°ï¼‰
    when gpu.ready {
        # æ ¹æ® GPU èƒ½åŠ›è°ƒæ•´ç­–ç•¥
    }
    
    # æ ¹æ®ç­–ç•¥è°ƒæ•´ç»Ÿä¸€åœº
    when fate.strategy == 1 {
        # é«˜æ€§èƒ½ï¼šæœ€å¤§åŒ–åˆ©ç”¨
        unified.information_density = 1.0
    }
    when fate.strategy == 3 {
        # å…¼å®¹ï¼šä¿å®ˆä½¿ç”¨
        unified.information_density = 0.5
        unified.entropy_gradient = 0.3
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åŒå‘ä¼˜åŒ– â€” ç»¼åˆé€‚åº”ä»»åŠ¡å’Œç¡¬ä»¶
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.check_adjust {
    # åªåœ¨åŠ¨æ€æ¨¡å¼ä¸‹ä¼˜åŒ–
    when fate.mode != "dynamic" { return }
    
    usage = fate.current_usage
    frag = tile.fragmentation()
    
    # 1. è§‚æµ‹ä»»åŠ¡
    fate.observe_task()
    
    # 2. é€‚åº”ä»»åŠ¡
    fate.adapt_to_task()
    
    # 3. é€‚åº”ç¡¬ä»¶
    fate.adapt_to_hardware()
    
    # 4. è°ƒæ•´ç»Ÿä¸€åœºå‚æ•°
    unified.adjust(usage, frag, task.pattern_count)
    
    # 5. æ£€æŸ¥æ˜¯å¦è§¦å‘ Collapseï¼ˆé™æ€åŒ–ï¼‰
    when fate.should_collapse(0) {
        fate.collapse(0)
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Collapse â€” ä»£ç é™æ€åŒ–
# Fate ç›‘æ§ä»£ç æ‰§è¡Œï¼Œå½“è¾¹é™…æ”¶ç›Šä¸è¶³æ—¶è§¦å‘é™æ€åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

collapse {
    marginal_threshold: 0.05    # è¾¹é™…æ”¶ç›Šé˜ˆå€¼
    previous_gain: 0
    static_count: 0
}

# æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘ Collapseï¼ˆé™æ€åŒ–ï¼‰
fn fate.should_collapse current_gain {
    gain_diff = current_gain - collapse.previous_gain
    collapse.previous_gain = current_gain
    
    # è¾¹é™…æ”¶ç›Šä½äºé˜ˆå€¼ â†’ è§¦å‘é™æ€åŒ–
    when gain_diff < collapse.marginal_threshold {
    }
}

# æ‰§è¡Œ Collapse â€” é™æ€åŒ–ä»£ç 
fn fate.collapse code_block {
    collapse.static_count = collapse.static_count + 1
    
    # æŠŠåŠ¨æ€ä»£ç è·¯å¾„å›ºåŒ–ä¸ºé™æ€
    # 1. è®°å½•å½“å‰ç»Ÿä¸€åœºå‚æ•°ä½œä¸ºé™æ€å€¼
    # 2. å›ºåŒ– Tile åˆ†é…ç­–ç•¥
    # 3. åœæ­¢åŠ¨æ€ä¼˜åŒ–
    
    static_info = unified.information_density
    static_entropy = unified.entropy_gradient
    static_relation = unified.relation_strength
    
    # åˆ‡æ¢åˆ°é™æ€æ¨¡å¼
    fate.mode = "static"
    
}

# Fate è‡ªåŠ¨ä¼˜åŒ–å¾ªç¯
fn fate.optimize_loop body {
    iteration = 0
    previous_result = 0
    
    loop {
        current_result = body()
        iteration = iteration + 1
        
        # è®¡ç®—è¾¹é™…æ”¶ç›Š
        gain = current_result - previous_result
        previous_result = current_result
        
        # æ£€æŸ¥æ˜¯å¦è§¦å‘ Collapse
        when fate.should_collapse(gain) {
            fate.collapse(body)
            break
        }
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GPU è‡ªé€‚åº”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.report_gpu info {
    gpu.vendor = info.vendor
    gpu.vram = info.vram
    gpu.max_w = info.max_width
    gpu.max_h = info.max_height
    
    # æ ¹æ® GPU èƒ½åŠ›è°ƒæ•´ç»Ÿä¸€åœº
    when gpu.vram >= 67108864 {
        unified.information_density = 1.0
        fate.strategy = 1
    }
    when gpu.vram >= 8388608 {
        when gpu.vram < 67108864 {
            unified.information_density = 0.7
            fate.strategy = 2
        }
    }
    when gpu.vram < 8388608 {
        unified.information_density = 0.4
        unified.entropy_gradient = 0.5
        fate.strategy = 3
    }
    
    gpu.ready = true
}

fn fate.best_width {
    when fate.strategy == 1 { -> gpu.max_w }
    when fate.strategy == 2 {
        when gpu.max_w > 1280 { -> 1280 }
    }
}

fn fate.best_height {
    when fate.strategy == 1 { -> gpu.max_h }
    when fate.strategy == 2 {
        when gpu.max_h > 720 { -> 720 }
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ€§èƒ½ç›‘æ§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.frame_begin {
    perf.frame_start = @0x11002004
}

fn fate.frame_end {
    frame_end = @0x11002004
    perf.frame_time = frame_end - perf.frame_start
    perf.frame_count = perf.frame_count + 1
    
    when perf.frame_time > 0 {
        perf.fps = 1000 / perf.frame_time
    }
    
    when perf.fps < 30 {
        fate.collapse()
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# limit è¯­æ³•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.set_limit percent {
    fate.resource_limit = percent
}

intent limit {
    action: fate.set_limit
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆå§‹åŒ–å’ŒæŠ¥å‘Š
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.init {
    fate.enabled = true
    fate.current_usage = 0
    fate.peak_usage = 0
    fate.collapse_count = 0
    fate.strategy = 2
    fate.mode = "dynamic"    # å¯åŠ¨æ—¶ä¸ºåŠ¨æ€æ¨¡å¼
    
    # åˆå§‹åŒ–ä»»åŠ¡è§‚æµ‹
    task.compute_heavy = false
    task.memory_heavy = false
    task.io_heavy = false
    task.pattern_count = 0
    task.loop_count = 0
    task.branch_ratio = 0.0
    
    gpu.ready = false
    perf.frame_count = 0
    perf.fps = 60
    
    unified.init()
    tile.init()
}

# ç¦ç”¨ Fate â€” åˆ‡æ¢åˆ°é™æ€æ¨¡å¼
fn fate.disable {
    fate.enabled = false
    fate.mode = "static"
}

# å¯ç”¨ Fate â€” åˆ‡æ¢åˆ°åŠ¨æ€æ¨¡å¼
fn fate.enable {
    fate.enabled = true
    fate.mode = "dynamic"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# fate on / fate off è¯­æ³•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

intent "fate on" {
    action: fate.enable
}

intent "fate off" {
    action: fate.disable
}

fn fate.report {
    unified.report()
    tile.report()
}

# â•â•â• codegen.wave â•â•â•
# ğŸŒŠ Wave ä»£ç ç”Ÿæˆ
# è§„åˆ™ç»„åˆ â†’ x86-64 æœºå™¨ç 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æœºå™¨ç åŸè¯­ (x86-64)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å¯„å­˜å™¨ç¼–ç 
reg {
    rax: 0
    rcx: 1
    rdx: 2
    rbx: 3
    rsp: 4
    rbp: 5
    rsi: 6
    rdi: 7
}

# syscall ç¼–å· (Linux)
sys {
    read: 0
    write: 1
    open: 2
    close: 3
    exit: 60
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æŒ‡ä»¤ç”Ÿæˆå‡½æ•°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# push rbp
fn gen.push_rbp {
    emit "\x55"
}

# pop rbp
fn gen.pop_rbp {
    emit "\x5d"
}

# mov rbp, rsp
fn gen.mov_rbp_rsp {
    emit "\x48\x89\xe5"
}

# mov rsp, rbp
fn gen.mov_rsp_rbp {
    emit "\x48\x89\xec"
}

# sub rsp, imm8
fn gen.sub_rsp imm8 {
    emit "\x48\x83\xec"
    emit imm8
}

# mov rax, imm64
fn gen.mov_rax imm64 {
    emit "\x48\xb8"
    emit imm64  # 8 bytes
}

# mov rdi, imm64
fn gen.mov_rdi imm64 {
    emit "\x48\xbf"
    emit imm64
}

# mov rsi, imm64
fn gen.mov_rsi imm64 {
    emit "\x48\xbe"
    emit imm64
}

# mov rdx, imm64
fn gen.mov_rdx imm64 {
    emit "\x48\xba"
    emit imm64
}

# syscall
fn gen.syscall {
    emit "\x0f\x05"
}

# ret
fn gen.ret {
    emit "\xc3"
}

# jmp rel32
fn gen.jmp offset {
    emit "\xe9"
    emit offset  # 4 bytes
}

# jz rel32
fn gen.jz offset {
    emit "\x0f\x84"
    emit offset
}

# jnz rel32
fn gen.jnz offset {
    emit "\x0f\x85"
    emit offset
}

# call rel32
fn gen.call offset {
    emit "\xe8"
    emit offset
}

# test rax, rax
fn gen.test_rax_rax {
    emit "\x48\x85\xc0"
}

# pause (ä½åŠŸè€—ç­‰å¾…)
fn gen.pause {
    emit "\xf3\x90"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™åˆ°æœºå™¨ç æ˜ å°„
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å‡½æ•°åºè¨€ (boundary è§„åˆ™ï¼šå»ºç«‹è¾¹ç•Œ)
fn codegen.prologue {
    gen.push_rbp()
    gen.mov_rbp_rsp()
    gen.sub_rsp(64)
}

# å‡½æ•°å°¾å£° (boundary è§„åˆ™ï¼šé‡Šæ”¾è¾¹ç•Œ)
fn codegen.epilogue {
    gen.mov_rsp_rbp()
    gen.pop_rbp()
    gen.ret()
}

# è¾“å‡ºå­—ç¬¦ä¸² (tension + connection è§„åˆ™)
fn codegen.write_string addr len {
    gen.mov_rax(sys.write)
    gen.mov_rdi(1)          # stdout
    gen.mov_rsi(addr)
    gen.mov_rdx(len)
    gen.syscall()
}

# é€€å‡ºç¨‹åº (boundary è§„åˆ™ï¼šç»ˆæ­¢)
fn codegen.exit code {
    gen.mov_rax(sys.exit)
    gen.mov_rdi(code)
    gen.syscall()
}

# æ— é™å¾ªç¯ (orbital è§„åˆ™ï¼šé—­åˆè½¨é“)
fn codegen.infinite_loop {
    # jmp -5 (è·³å›è‡ªèº«)
    emit "\xe9\xfb\xff\xff\xff"
}

# äº‹ä»¶å¾ªç¯ (orbital + memory è§„åˆ™)
fn codegen.event_loop {
    # loop:
    #   pause
    #   jmp loop
    gen.pause()
    emit "\xeb\xfc"  # jmp -4
}

# æ¡ä»¶è·³è½¬ (tension + entropy è§„åˆ™)
fn codegen.conditional_jump condition target {
    gen.test_rax_rax()
    when condition == "zero" {
        gen.jz(target)
    }
    when condition == "nonzero" {
        gen.jnz(target)
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ„å›¾ç¼–è¯‘
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ç¼–è¯‘ out "text"
fn compile.out text {
    addr = data.add_string(text)
    len = text.length + 1
    codegen.write_string(addr, len)
}

# ç¼–è¯‘ emit "bytes"
fn compile.emit bytes {
    emit bytes  # ç›´æ¥è¾“å‡º
}

# ç¼–è¯‘ fn name { body }
fn compile.fn name body {
    label.add(name)
    codegen.prologue()
    compile(body)
    codegen.epilogue()
}

# ç¼–è¯‘ loop { body }
fn compile.loop body {
    start = label.current()
    compile(body)
    gen.jmp(start - label.current() - 5)
}

# ç¼–è¯‘ keep
fn compile.keep {
    codegen.event_loop()
}

# ç¼–è¯‘ syscall.exit(code)
fn compile.exit code {
    codegen.exit(code)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Fate æ¨¡å¼åˆ‡æ¢ä»£ç ç”Ÿæˆ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# fate on â€” å¯ç”¨åŠ¨æ€ä¼˜åŒ–
fn compile.fate_enable {
    # è®¾ç½® fate.enabled = true
    # åœ°å€: 0x401000 (fate çŠ¶æ€åŒº)
    gen.mov_rax(1)
    emit "\x48\xa3"                    # mov [addr], rax
    emit "\x00\x10\x40\x00\x00\x00\x00\x00"  # 0x401000
}

# fate off â€” é™æ€æ¨¡å¼
fn compile.fate_disable {
    # è®¾ç½® fate.enabled = false
    gen.mov_rax(0)
    emit "\x48\xa3"
    emit "\x00\x10\x40\x00\x00\x00\x00\x00"
}

# limit N â€” èµ„æºé™åˆ¶
fn compile.limit percent {
    gen.mov_rax(percent)
    emit "\x48\xa3"
    emit "\x08\x10\x40\x00\x00\x00\x00\x00"  # 0x401008 (èµ„æºé™åˆ¶)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Fate ä¼˜åŒ–é’©å­ï¼ˆåŠ¨æ€æ¨¡å¼æ—¶æ’å…¥ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# æ£€æŸ¥æ˜¯å¦ä¸ºåŠ¨æ€æ¨¡å¼
fn codegen.check_fate_mode {
    # æ£€æŸ¥ [0x401000]
    emit "\x48\xa1"
    emit "\x00\x10\x40\x00\x00\x00\x00\x00"
    gen.test_rax_rax()
    # è¿”å›å€¼åœ¨ ZF ä¸­
}

# æµ‹é‡å¼€å§‹é’©å­
fn codegen.fate_measure_begin {
    # ä¿å­˜æ—¶é—´æˆ³åˆ° [0x401010]
    emit "\x0f\x31"                    # rdtsc
    emit "\x48\xa3"
    emit "\x10\x10\x40\x00\x00\x00\x00\x00"
}

# æµ‹é‡ç»“æŸé’©å­ + è¾¹é™…æ”¶ç›Šæ£€æŸ¥
fn codegen.fate_measure_end {
    # è¯»å–å½“å‰æ—¶é—´æˆ³
    emit "\x0f\x31"                    # rdtsc
    # å‡å»å¼€å§‹æ—¶é—´
    emit "\x48\x2b\x04\x25"
    emit "\x10\x10\x40\x00"            # sub rax, [0x401010]
    # ä¿å­˜å¢é‡
    emit "\x48\xa3"
    emit "\x18\x10\x40\x00\x00\x00\x00\x00"  # 0x401018
    
    # æ£€æŸ¥è¾¹é™…æ”¶ç›Š
    # å¦‚æœå¢é‡ < é˜ˆå€¼ï¼Œè§¦å‘ Collapse
    emit "\x48\x3d"                    # cmp rax, imm32
    emit "\x00\x10\x00\x00"            # 0x1000 (é˜ˆå€¼)
    # å¦‚æœå°äºï¼Œè·³è½¬åˆ° collapse
}

# å¸¦ Fate ä¼˜åŒ–çš„å¾ªç¯
fn codegen.loop_with_fate body {
    start = label.current()
    
    # æ£€æŸ¥ Fate æ¨¡å¼
    codegen.check_fate_mode()
    gen.jz(skip_measure)              # é™æ€æ¨¡å¼è·³è¿‡æµ‹é‡
    
    # åŠ¨æ€æ¨¡å¼ï¼šæ’å…¥æµ‹é‡
    codegen.fate_measure_begin()
    
    skip_measure:
    # æ‰§è¡Œå¾ªç¯ä½“
    compile(body)
    
    # æ£€æŸ¥ Fate æ¨¡å¼
    codegen.check_fate_mode()
    gen.jz(skip_check)
    
    # åŠ¨æ€æ¨¡å¼ï¼šæ£€æŸ¥è¾¹é™…æ”¶ç›Š
    codegen.fate_measure_end()
    # å¦‚æœåº”è¯¥ Collapseï¼Œè·³å‡ºå¾ªç¯
    
    skip_check:
    gen.jmp(start - label.current() - 5)
}

# å¸¦ Fate ä¼˜åŒ–çš„å‡½æ•°è°ƒç”¨
fn codegen.call_with_fate addr {
    # æ£€æŸ¥ Fate æ¨¡å¼
    codegen.check_fate_mode()
    gen.jz(static_call)
    
    # åŠ¨æ€æ¨¡å¼ï¼šæµ‹é‡è°ƒç”¨
    codegen.fate_measure_begin()
    gen.call(addr)
    codegen.fate_measure_end()
    gen.jmp(done)
    
    static_call:
    gen.call(addr)
    
    done:
}

# â•â•â• compiler.wave â•â•â•
# ğŸŒŠ Wave è‡ªä¸¾ç¼–è¯‘å™¨
# è§£ææºç  â†’ è§„åˆ™æ˜ å°„ â†’ ä»£ç ç”Ÿæˆ


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ç¼–è¯‘å™¨çŠ¶æ€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

compiler {
    source: ""
    pos: 0
    len: 0
    fate_mode: true
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ç¼–è¯‘å…¥å£
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.compile source {
    compiler.source = source
    compiler.pos = 0
    compiler.len = source.length
    
    # åˆå§‹åŒ–
    fate.init()
    tile.init()
    unified.init()
    
    # å¹³å°å†…æ ¸åˆå§‹åŒ– â€” è‡ªåŠ¨æ£€æµ‹å¹³å°
    env.init()
    
    # æ”¶é›†ä»£ç 
    code_buffer = []
    
    # ä»£ç åºè¨€
    code_buffer <- codegen.prologue()
    
    # è§£æå¹¶ç¼–è¯‘åˆ°ç¼“å†²åŒº
    compiler.parse_all_to(code_buffer)
    
    # ä»£ç å°¾å£°
    code_buffer <- codegen.exit(0)
    
    # é€šè¿‡å¹³å°å†…æ ¸è¾“å‡ºï¼ˆè‡ªåŠ¨é€‰æ‹©æ ¼å¼ï¼‰
    env.output(code_buffer)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£æä¸»å¾ªç¯ â€” orbital è§„åˆ™ï¼ˆå¾ªç¯è½¨é“ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_all {
    loop {
        compiler.skip_whitespace()
        
        when compiler.pos >= compiler.len {
            break
        }
        
        compiler.parse_statement()
    }
}

fn compiler.parse_all_to buffer {
    loop {
        compiler.skip_whitespace()
        
        when compiler.pos >= compiler.len {
            break
        }
        
        compiler.parse_statement_to(buffer)
    }
}

fn compiler.parse_statement_to buffer {
    # è§£æè¯­å¥å¹¶æ”¶é›†åˆ° buffer
    compiler.parse_statement()
    # ä»£ç é€šè¿‡ emit å·²è¾“å‡ºåˆ° buffer
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è¯­å¥è§£æ â€” tension è§„åˆ™ï¼ˆé€‰æ‹©æ€§å¼ åŠ›ï¼‰
# æ ¹æ®é¦–å­—ç¬¦/å…³é”®å­—é€‰æ‹©åˆ†æ”¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_statement {
    # æ³¨é‡Š â€” entropy è§„åˆ™ï¼ˆè·³è¿‡æ— åºï¼‰
    when compiler.char() == 35 {  # '#'
        compiler.skip_line()
        return
    }
    
    # out "text" â€” intent.out
    when compiler.match("out ") {
        compiler.pos = compiler.pos + 4
        compiler.skip_whitespace()
        text = compiler.parse_string()
        compile.out(text)
        return
    }
    
    # emit "bytes" â€” intent.emit
    when compiler.match("emit ") {
        compiler.pos = compiler.pos + 5
        compiler.skip_whitespace()
        bytes = compiler.parse_string()
        compile.emit(bytes)
        return
    }
    
    # fn name { body } â€” intent.fn
    when compiler.match("fn ") {
        compiler.pos = compiler.pos + 3
        compiler.skip_whitespace()
        name = compiler.parse_ident()
        compiler.skip_whitespace()
        body = compiler.parse_block()
        compile.fn(name, body)
        return
    }
    
    # when cond { body } â€” intent.when
    when compiler.match("when ") {
        compiler.pos = compiler.pos + 5
        cond = compiler.parse_expr()
        body = compiler.parse_block()
        compile.when(cond, body)
        return
    }
    
    # loop { body } â€” intent.loop
    when compiler.match("loop") {
        compiler.pos = compiler.pos + 4
        compiler.skip_whitespace()
        body = compiler.parse_block()
        
        when compiler.fate_mode {
            codegen.loop_with_fate(body)
        }
        when compiler.fate_mode == false {
            compile.loop(body)
        }
        return
    }
    
    # keep â€” intent.keep
    when compiler.match("keep") {
        compiler.pos = compiler.pos + 4
        compile.keep()
        return
    }
    
    # fate on/off â€” intent.fate
    when compiler.match("fate on") {
        compiler.pos = compiler.pos + 7
        compiler.fate_mode = true
        compile.fate_enable()
        return
    }
    when compiler.match("fate off") {
        compiler.pos = compiler.pos + 8
        compiler.fate_mode = false
        compile.fate_disable()
        return
    }
    
    # limit N â€” intent.limit
    when compiler.match("limit ") {
        compiler.pos = compiler.pos + 6
        n = compiler.parse_number()
        compile.limit(n)
        return
    }
    
    # syscall.exit(N)
    when compiler.match("syscall.exit(") {
        compiler.pos = compiler.pos + 13
        code = compiler.parse_number()
        compiler.pos = compiler.pos + 1  # ')'
        compile.exit(code)
        return
    }
    
    # å˜é‡èµ‹å€¼ x = value â€” intent.assign
    when compiler.is_ident_start() {
        name = compiler.parse_ident()
        compiler.skip_whitespace()
        when compiler.char() == 61 {  # '='
            compiler.pos = compiler.pos + 1
            compiler.skip_whitespace()
            value = compiler.parse_expr()
            compile.assign(name, value)
            return
        }
        # å‡½æ•°è°ƒç”¨ name()
        when compiler.char() == 40 {  # '('
            compiler.pos = compiler.pos + 1
            compiler.skip_whitespace()
            compiler.pos = compiler.pos + 1  # ')'
            compile.call(name)
            return
        }
    }
    
    # å…¶ä»–ï¼šè·³è¿‡
    compiler.pos = compiler.pos + 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å­—ç¬¦æ“ä½œ â€” memory è§„åˆ™ï¼ˆè®°å¿†å­˜å–ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.char {
    when compiler.pos < compiler.len {
    }
}

fn compiler.peek offset {
    idx = compiler.pos + offset
    when idx < compiler.len {
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åŒ¹é… â€” connection è§„åˆ™ï¼ˆè¿æ¥æ¯”è¾ƒï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.match expected {
    i = 0
    elen = expected.length
    
    loop {
        when i >= elen {
        }
        
        idx = compiler.pos + i
        when idx >= compiler.len {
        }
        
        when compiler.source[idx] != expected[i] {
        }
        
        i = i + 1
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è·³è¿‡ç©ºç™½ â€” entropy è§„åˆ™ï¼ˆæ— åºè·³è¿‡ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.skip_whitespace {
    loop {
        when compiler.pos >= compiler.len { break }
        
        c = compiler.char()
        
        when c == 32 { compiler.pos = compiler.pos + 1 }   # ç©ºæ ¼
        when c == 9 { compiler.pos = compiler.pos + 1 }    # Tab
        when c == 10 { compiler.pos = compiler.pos + 1 }   # LF
        when c == 13 { compiler.pos = compiler.pos + 1 }   # CR
        when c != 32 {
            when c != 9 {
                when c != 10 {
                    when c != 13 { break }
                }
            }
        }
    }
}

fn compiler.skip_line {
    loop {
        when compiler.pos >= compiler.len { break }
        c = compiler.char()
        compiler.pos = compiler.pos + 1
        when c == 10 { break }
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£æå­—ç¬¦ä¸² â€” boundary è§„åˆ™ï¼ˆè¾¹ç•Œå®šä¹‰ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_string {
    # è·³è¿‡å¼€å¼•å·
    when compiler.char() == 34 {
        compiler.pos = compiler.pos + 1
    }
    
    start = compiler.pos
    
    loop {
        when compiler.pos >= compiler.len { break }
        
        c = compiler.char()
        
        # ç»“æŸå¼•å·
        when c == 34 { break }
        
        # è½¬ä¹‰
        when c == 92 {
            compiler.pos = compiler.pos + 2
        }
        when c != 92 {
            compiler.pos = compiler.pos + 1
        }
    }
    
    end = compiler.pos
    
    # è·³è¿‡é—­å¼•å·
    when compiler.char() == 34 {
        compiler.pos = compiler.pos + 1
    }
    
    # è¿”å›å­—ç¬¦ä¸²ï¼ˆç”¨ Tile åˆ†é…ï¼‰
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£ææ•°å­— â€” gravitational è§„åˆ™ï¼ˆèšåˆï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_number {
    num = 0
    
    loop {
        when compiler.pos >= compiler.len { break }
        
        c = compiler.char()
        
        # æ•°å­— 0-9 (ASCII 48-57)
        when c >= 48 {
            when c <= 57 {
                digit = c - 48
                num = num * 10 + digit
                compiler.pos = compiler.pos + 1
            }
            when c > 57 { break }
        }
        when c < 48 { break }
    }
    
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£ææ ‡è¯†ç¬¦ â€” boundary + connection
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.is_ident_start {
    c = compiler.char()
    # a-z A-Z _
    when c >= 97 { when c <= 122 { -> true } }
    when c >= 65 { when c <= 90 { -> true } }
    when c == 95 { -> true }
}

fn compiler.is_ident_char {
    c = compiler.char()
    # a-z A-Z 0-9 _ .
    when c >= 97 { when c <= 122 { -> true } }
    when c >= 65 { when c <= 90 { -> true } }
    when c >= 48 { when c <= 57 { -> true } }
    when c == 95 { -> true }
    when c == 46 { -> true }
}

fn compiler.parse_ident {
    start = compiler.pos
    
    loop {
        when compiler.pos >= compiler.len { break }
        when compiler.is_ident_char() == false { break }
        compiler.pos = compiler.pos + 1
    }
    
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£æå— â€” boundary è§„åˆ™ï¼ˆè¾¹ç•ŒåµŒå¥—ï¼‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_block {
    compiler.skip_whitespace()
    
    # è·³è¿‡ '{'
    when compiler.char() == 123 {
        compiler.pos = compiler.pos + 1
    }
    
    start = compiler.pos
    depth = 1
    
    loop {
        when compiler.pos >= compiler.len { break }
        when depth == 0 { break }
        
        c = compiler.char()
        
        when c == 123 { depth = depth + 1 }
        when c == 125 { depth = depth - 1 }
        
        compiler.pos = compiler.pos + 1
    }
    
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§£æè¡¨è¾¾å¼ â€” tension + gravitational
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compiler.parse_expr {
    compiler.skip_whitespace()
    
    # æ•°å­—
    c = compiler.char()
    when c >= 48 {
        when c <= 57 {
        }
    }
    
    # æ ‡è¯†ç¬¦
    when compiler.is_ident_start() {
    }
    
    # å­—ç¬¦ä¸²
    when c == 34 {
    }
    
}

# â•â•â• kernel.wave â•â•â•
# ğŸŒŠ Wave è·¨å¹³å°æœ€å°å†…æ ¸
# å·²çŸ¥å¹³å° â†’ åº“åŠ è½½
# æœªçŸ¥å¹³å° â†’ Fate æ¢æµ‹å­¦ä¹ 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å¹³å°åº“ â€” æœ€å°æ¡¥æ¥ï¼ŒæŒ‰éœ€åŠ è½½
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

lib {
    linux: "platform/linux.wave"
    macos: "platform/macos.wave"
    windows: "platform/windows.wave"
    # æœªæ¥å¹³å°è‡ªåŠ¨æ·»åŠ 
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ç¯å¢ƒçŠ¶æ€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

env {
    known: false      # æ˜¯å¦å·²çŸ¥å¹³å°
    lib_loaded: ""    # åŠ è½½çš„åº“
    features: []      # æ¢æµ‹ç‰¹å¾ï¼ˆæœªçŸ¥å¹³å°ç”¨ï¼‰
    header: []
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å…¥å£ â€” å°è¯•åŠ è½½å·²çŸ¥åº“ï¼Œå¦åˆ™æ¢æµ‹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn env.init {
    # å°è¯•åŠ è½½å·²çŸ¥å¹³å°åº“
    env.try_load_lib()
    
    when env.known == false {
        # æœªçŸ¥å¹³å°ï¼šFate æ¢æµ‹
        env.probe()
        env.learn()
    }
}

fn env.try_load_lib {
    # ä¾æ¬¡å°è¯•åŠ è½½åº“ï¼Œå“ªä¸ªæˆåŠŸå°±ç”¨å“ªä¸ª
    
    when env.try_linux() {
        env.known = true
        env.lib_loaded = "linux"
        return
    }
    
    when env.try_macos() {
        env.known = true
        env.lib_loaded = "macos"
        return
    }
    
    when env.try_windows() {
        env.known = true
        env.lib_loaded = "windows"
        return
    }
    
    # éƒ½å¤±è´¥ â†’ æœªçŸ¥å¹³å°
    env.known = false
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å¹³å°æ£€æµ‹ â€” æœ€å°æµ‹è¯•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn env.try_linux {
    # Linux: syscall 39 (getpid) è¿”å› > 0
    emit "\x48\xc7\xc0\x27\x00\x00\x00"  # mov rax, 39
    emit "\x0f\x05"                       # syscall
}

fn env.try_macos {
    # macOS: syscall ç¼–å·ä¸åŒï¼Œ20 æ˜¯ getpid
    emit "\x48\xc7\xc0\x14\x00\x00\x00"  # mov rax, 20
    emit "\x0f\x05"                       # syscall
}

fn env.try_windows {
    # Windows: æ£€æŸ¥ PEB åœ°å€
    emit "\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60]
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è¾“å‡º â€” ä½¿ç”¨åº“æˆ–æ¢æµ‹ç»“æœ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn env.output code {
    env.init()
    
    when env.known {
        # å·²çŸ¥å¹³å°ï¼šç”¨åº“
        env.output_with_lib(code)
    }
    when env.known == false {
        # æœªçŸ¥å¹³å°ï¼šç”¨æ¢æµ‹ç»“æœ
        env.output_with_probe(code)
    }
}

fn env.output_with_lib code {
    when env.lib_loaded == "linux" {
        linux.emit_header()
    }
    when env.lib_loaded == "macos" {
        macos.emit_header()
    }
    when env.lib_loaded == "windows" {
        windows.emit_header()
    }
    
    emit code
}

fn env.output_with_probe code {
    emit env.header
    emit code
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æœªçŸ¥å¹³å°æ¢æµ‹ â€” Fate å­¦ä¹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn env.probe {
    env.probe_word()
    env.probe_syscall()
    env.probe_memory()
}

fn env.probe_word {
    emit "\x48\x31\xc0"
    env.features <- 64
}

fn env.probe_syscall {
    emit "\x48\xc7\xc0\x27\x00\x00\x00"
    emit "\x0f\x05"
    env.features <- @rax
}

fn env.probe_memory {
    env.features <- @0x400000
}

fn env.learn {
    unified.information_density = len(env.features) / 10.0
    env.header = env.emerge_header()
}

fn env.emerge_header {
    header = []
    header <- 0x57  # 'W'
    header <- 0x41  # 'A'
    header <- 0x56  # 'V'
    header <- 0x45  # 'E'
    
    when 64 in env.features {
        header <- 0x02
    }
    when 64 not in env.features {
        header <- 0x01
    }
    
}

# â•â•â• linux.wave â•â•â•
# ğŸ§ Linux æœ€å°æ¡¥æ¥

fn linux.emit_header {
    # ELF64 å¤´
    emit "\x7fELF"           # magic
    emit "\x02"              # 64-bit
    emit "\x01"              # little endian
    emit "\x01"              # version
    emit "\x00\x00\x00\x00\x00\x00\x00\x00\x00"  # padding
    emit "\x02\x00"          # executable
    emit "\x3e\x00"          # x86_64
    emit "\x01\x00\x00\x00"  # version
}

fn linux.syscall num {
    emit "\x48\xc7\xc0"      # mov rax, num
    emit num
    emit "\x0f\x05"          # syscall
}

fn linux.exit code {
    linux.syscall(60)
}

# â•â•â• macos.wave â•â•â•
# ğŸ macOS æœ€å°æ¡¥æ¥

fn macos.emit_header {
    # Mach-O 64 å¤´
    emit "\xcf\xfa\xed\xfe"  # MH_MAGIC_64
    emit "\x07\x00\x00\x01"  # x86_64
    emit "\x03\x00\x00\x00"  # CPU subtype
    emit "\x02\x00\x00\x00"  # MH_EXECUTE
}

fn macos.syscall num {
    # macOS syscall: num + 0x2000000
    adjusted = num + 0x2000000
    emit "\x48\xc7\xc0"
    emit adjusted
    emit "\x0f\x05"
}

fn macos.exit code {
    macos.syscall(1)
}

# â•â•â• windows.wave â•â•â•
# ğŸªŸ Windows æœ€å°æ¡¥æ¥

fn windows.emit_header {
    # PE å¤´
    emit "MZ"                # DOS magic
    emit "\x90\x00"          # DOS stub padding
    emit "\x03\x00\x00\x00"
    emit "\x04\x00\x00\x00"
    emit "\xff\xff\x00\x00"
    # ... ç®€åŒ– DOS header
    
    # PE signature at 0x3C
    emit "PE\x00\x00"
    emit "\x64\x86"          # x86_64
}

fn windows.exit code {
    # Windows: call ExitProcess
    # éœ€è¦ kernel32.dll
    emit "\x48\x31\xc9"      # xor rcx, rcx (exit code 0)
    # call [ExitProcess]
}


fate.init()
tile.init()
unified.init()
env.init()
source = file.read(0, 0x10000)
compiler.compile(source)
syscall.exit(0)

