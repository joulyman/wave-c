# ğŸŒŠ Wave è·¨å¹³å°å†…æ ¸
# æ— é¢„è®¾ï¼ŒFate æ¢æµ‹ï¼Œä»£æ•°ç¼–å·

use rules/fate

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å¹³å°çŠ¶æ€ â€” ä»£æ•°å½¢å¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

platform {
    id: 0              # å¹³å°ç¼–å·ï¼ˆFate åˆ†é…ï¼‰
    syscall_base: 0    # syscall åŸºå€
    header_size: 0     # å¤´éƒ¨å¤§å°
    entry_offset: 0    # å…¥å£åç§»
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ³¨å†Œåˆ° Fate
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn platform.register {
    fate.register_adapter("platform", platform.adapt)
}

fn platform.adapt {
    # Fate æ¢æµ‹å¹³å°ç‰¹å¾
    platform.probe()
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ¢æµ‹ â€” Fate è‡ªåŠ¨å­¦ä¹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn platform.probe {
    # å°è¯• syscallï¼Œæ ¹æ®è¿”å›ç‰¹å¾åˆ†é…ç¼–å·
    # Fate ä¼šè®°å½•æˆåŠŸçš„æ¨¡å¼
    
    # æ¢æµ‹ 1: syscall 0x3c (60)
    result = platform.try_syscall(0x3c, 0, 0, 0)
    when result.success {
        platform.id = 1
        platform.syscall_base = 0
        -> 
    }
    
    # æ¢æµ‹ 2: syscall 0x2000001
    result = platform.try_syscall(0x2000001, 0, 0, 0)
    when result.success {
        platform.id = 2
        platform.syscall_base = 0x2000000
        ->
    }
    
    # æœªçŸ¥ï¼šåˆ†é…æ–°ç¼–å·
    platform.id = fate.next_id()
    platform.syscall_base = 0
}

fn platform.try_syscall num a b c {
    # ç”± codegen ç”Ÿæˆå®é™…æµ‹è¯•ä»£ç 
    # è¿”å› { success: bool }
    -> { success: false }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è¾“å‡º â€” æ ¹æ® Fate å­¦ä¹ çš„æ¨¡å¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn platform.emit_header {
    # æ ¹æ®å¹³å° ID è¾“å‡ºå¯¹åº”æ ¼å¼
    when platform.id == 1 {
        # Linux: ELF64
        emit 0x7f 0x45 0x4c 0x46  # .ELF
        emit 0x02 0x01 0x01 0x00  # 64-bit, LE, v1, SYSV
        emit 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
        emit 0x02 0x00 0x3e 0x00  # EXEC, x86_64
        emit 0x01 0x00 0x00 0x00  # version
        emit 0x78 0x00 0x40 0x00 0x00 0x00 0x00 0x00  # entry
        emit 0x40 0x00 0x00 0x00 0x00 0x00 0x00 0x00  # phoff
        emit 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00  # shoff
        emit 0x00 0x00 0x00 0x00 0x40 0x00 0x38 0x00
        emit 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00
        # Program header
        emit 0x01 0x00 0x00 0x00 0x05 0x00 0x00 0x00  # LOAD, R+X
        emit 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00  # offset
        emit 0x00 0x00 0x40 0x00 0x00 0x00 0x00 0x00  # vaddr
        emit 0x00 0x00 0x40 0x00 0x00 0x00 0x00 0x00  # paddr
        emit 0x00 0x02 0x00 0x00 0x00 0x00 0x00 0x00  # filesz
        emit 0x00 0x02 0x00 0x00 0x00 0x00 0x00 0x00  # memsz
        emit 0x00 0x10 0x00 0x00 0x00 0x00 0x00 0x00  # align
        ->
    }
    when platform.id == 2 {
        # macOS: Mach-O
        emit 0xcf 0xfa 0xed 0xfe  # MH_MAGIC_64
        emit 0x07 0x00 0x00 0x01  # x86_64
        emit 0x03 0x00 0x00 0x00  # CPU subtype
        emit 0x02 0x00 0x00 0x00  # MH_EXECUTE
        ->
    }
    # æœªçŸ¥å¹³å°ï¼šWAVE åŸç”Ÿ
    emit 0x57 0x41 0x56 0x45  # WAVE
    emit platform.id
}

fn platform.syscall num a b c {
    # åŠ ä¸Šå¹³å° syscall åŸºå€
    real_num = platform.syscall_base + num
    codegen.gen_syscall(real_num, a, b, c)
}
