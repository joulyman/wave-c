# ğŸ–¥ï¸ è£¸æœºåˆå§‹åŒ–
# Wave è‡ªå·±å®Œæˆï¼Œæ— å¤–éƒ¨ä¾èµ–

use drivers/bridge

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VESA BIOS æ‰©å±•
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.vbe_get_info mode {
    # VBE è·å–æ¨¡å¼ä¿¡æ¯
    # int 0x10, AX=0x4F01, CX=mode, ES:DI=buffer
    
    emit 0xB8 0x01 0x4F       # mov ax, 0x4F01
    emit 0xB9                 # mov cx, mode
    emit.u16 mode
    emit 0xBF 0x00 0x70       # mov di, 0x7000
    emit 0x06                 # push es
    emit 0x1E                 # push ds
    emit 0x07                 # pop es
    emit 0xCD 0x10            # int 0x10
    emit 0x07                 # pop es
}

fn bare.vbe_set_mode mode {
    # VBE è®¾ç½®æ¨¡å¼
    # int 0x10, AX=0x4F02, BX=mode|0x4000 (LFB)
    
    emit 0xB8 0x02 0x4F       # mov ax, 0x4F02
    emit 0xBB                 # mov bx, mode | 0x4000
    emit.u16 (mode | 0x4000)
    emit 0xCD 0x10            # int 0x10
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ¨¡å¼æ¢æµ‹ (ä¸å‡è®¾åˆ†è¾¨ç‡)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.probe_modes {
    # å°è¯•å¸¸è§æ¨¡å¼ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„
    modes = [
        0x118,   # 1024x768x32
        0x115,   # 800x600x32
        0x112,   # 640x480x32
        0x101    # 640x480x8
    ]
    
    i = 0
    loop {
        when i >= len(modes) { break }
        
        mode = modes[i]
        bare.vbe_get_info(mode)
        
        # æ£€æŸ¥æ˜¯å¦æ”¯æŒ
        attrs = @0x7000
        when (attrs & 0x01) != 0 {
            # æ¨¡å¼å¯ç”¨
            -> mode
        }
        
        i = i + 1
    }
    
    # æ²¡æœ‰å¯ç”¨æ¨¡å¼
    -> 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆå§‹åŒ– (å¡«å……æ ‡å‡†åœ°å€)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.init {
    mode = bare.probe_modes()
    
    when mode == 0 {
        # å›é€€åˆ° VGA 320x200x8
        emit 0xB8 0x13 0x00   # mov ax, 0x0013
        emit 0xCD 0x10        # int 0x10
        
        @addr.display.fb = 0xA0000
        @addr.display.width = 320
        @addr.display.height = 200
        @addr.display.pitch = 320
        @addr.display.format = 2    # 8-bit è°ƒè‰²æ¿
        @addr.display.ready = 1
        return
    }
    
    # è·å– VBE æ¨¡å¼ä¿¡æ¯
    bare.vbe_get_info(mode)
    
    # ä» VBE ä¿¡æ¯å—è¯»å–
    @addr.display.fb = @0x7028         # PhysBasePtr
    @addr.display.width = @0x7012      # XResolution
    @addr.display.height = @0x7014     # YResolution
    @addr.display.pitch = @0x7010      # BytesPerScanLine
    
    # æ£€æµ‹åƒç´ æ ¼å¼
    bpp = @0x7019
    when bpp == 32 {
        red_pos = @0x701F
        when red_pos == 16 {
            @addr.display.format = 0   # RGBA
        }
        when red_pos == 0 {
            @addr.display.format = 1   # BGRA
        }
    }
    when bpp == 24 {
        @addr.display.format = 3       # RGB24
    }
    when bpp == 16 {
        @addr.display.format = 4       # RGB565
    }
    when bpp == 8 {
        @addr.display.format = 2       # è°ƒè‰²æ¿
    }
    
    # è®¾ç½®æ¨¡å¼
    bare.vbe_set_mode(mode)
    
    # æ ‡è®°å°±ç»ª
    @addr.display.ready = 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# é”®ç›˜åˆå§‹åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.init_keyboard {
    @addr.input.buffer = 0x2100    # é”®ç›˜ç¼“å†²åŒº
    @addr.input.head = 0
    @addr.input.tail = 0
    @addr.input.ready = 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ—¶é’Ÿåˆå§‹åŒ– (PIT)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.init_timer {
    # PIT é¢‘ç‡ 1193182 Hz
    @addr.time.freq = 1193182
    @addr.time.ticks = 0
    
    # è®¾ç½® PIT é€šé“ 0
    emit 0xB0 0x36            # mov al, 0x36
    emit 0xE6 0x43            # out 0x43, al
    emit 0xB0 0x00            # mov al, 0 (é™¤æ•°ä½å­—èŠ‚)
    emit 0xE6 0x40            # out 0x40, al
    emit 0xB0 0x00            # mov al, 0 (é™¤æ•°é«˜å­—èŠ‚)
    emit 0xE6 0x40            # out 0x40, al
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å®Œæ•´åˆå§‹åŒ–
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn bare.full_init {
    bare.init()
    bare.init_keyboard()
    bare.init_timer()
}
