# ðŸŒŠ Wave æ ¸å¿ƒè§„åˆ™
# æ‰€æœ‰è§„åˆ™ä»Žç»Ÿä¸€åœºæ´¾ç”Ÿ

use rules/unified

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ´¾ç”Ÿè§„åˆ™ - ç»Ÿä¸€åœºçš„ä¸åŒè¡¨è¾¾
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å¼•åŠ›è§„åˆ™
gravitational = derive.gravitational()

# å¼ åŠ›è§„åˆ™
tension = derive.tension()

# ç†µè§„åˆ™
entropy = derive.entropy()

# è¿žæŽ¥è§„åˆ™
connection = derive.connection()

# è®°å¿†è§„åˆ™
memory = derive.memory()

# è½¨é“è§„åˆ™
orbital = derive.orbital()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™è¯„ä¼° - è®¡ç®—è§„åˆ™åœ¨å½“å‰çŠ¶æ€ä¸‹çš„å¼ºåº¦
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn rule.evaluate name context {
    when name == "gravitational" {
        -> gravitational.strength * context.mass
    }
    when name == "tension" {
        -> tension.base + tension.accumulation * context.time
    }
    when name == "entropy" {
        -> entropy.initial + entropy.growth * context.time
    }
    when name == "connection" {
        -> connection.strength * context.count
    }
    when name == "memory" {
        -> memory.persistence * context.age
    }
    when name == "orbital" {
        -> orbital.stability * context.period
    }
    -> 0.0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™åº”ç”¨ - å°†è§„åˆ™æ•ˆæžœæ–½åŠ åˆ°ç»“æž„
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn rule.apply name structure intensity {
    when name == "gravitational" {
        # å¸å¼•æ•ˆæžœ
        structure.position = structure.position - intensity * structure.distance
    }
    when name == "tension" {
        # å¼ åŠ›æ•ˆæžœ
        structure.stress = structure.stress + intensity
        when structure.stress > tension.release {
            structure.stress = 0.0
            # è§¦å‘é‡Šæ”¾
        }
    }
    when name == "entropy" {
        # ç†µå¢žæ•ˆæžœ
        structure.disorder = structure.disorder + intensity
    }
    when name == "connection" {
        # è¿žæŽ¥æ•ˆæžœ
        structure.links = structure.links + intensity
    }
    when name == "memory" {
        # è®°å¿†æ•ˆæžœ
        structure.retention = structure.retention * (1.0 - memory.decay)
    }
    when name == "orbital" {
        # è½¨é“æ•ˆæžœ
        structure.phase = structure.phase + intensity / orbital.period
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™ç»„åˆ - å¤šè§„åˆ™ååŒ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ç»„åˆä¸å†æ˜¯é¢„å®šä¹‰çš„å››å…ƒç³»ç»Ÿ
# è€Œæ˜¯æ ¹æ®éœ€è¦åŠ¨æ€ç»„åˆ

fn rules.combine names weights context {
    total = 0.0
    
    i = 0
    loop {
        when i >= names.length { break }
        name = names[i]
        weight = weights[i]
        value = rule.evaluate(name, context)
        total = total + weight * value
        i = i + 1
    }
    
    -> total
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å¸¸ç”¨ç»„åˆ (æ›¿ä»£å››å…ƒç³»ç»Ÿ)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# é«˜å¯†åº¦å­˜å‚¨ (åŽŸ BlackHole åŠŸèƒ½)
fn combine.dense context {
    -> rules.combine(
        ["gravitational", "memory"],
        [0.7, 0.3],
        context
    )
}

# æ¨¡å¼è¯†åˆ« (åŽŸ MeshBrain åŠŸèƒ½)
fn combine.pattern context {
    -> rules.combine(
        ["connection", "memory", "entropy"],
        [0.5, 0.3, 0.2],
        context
    )
}

# å¤§è§„æ¨¡å¹¶è¡Œ (åŽŸ MultiNova åŠŸèƒ½)
fn combine.parallel context {
    -> rules.combine(
        ["orbital", "tension"],
        [0.6, 0.4],
        context
    )
}

# å¿«é€Ÿç¢Žç‰‡ (åŽŸ BaseForce åŠŸèƒ½)
fn combine.fast context {
    -> rules.combine(
        ["tension", "entropy"],
        [0.5, 0.5],
        context
    )
}
