# ğŸ§± Tile å†…å­˜ç®¡ç†å™¨
# æ— é¢„è®¾åœ°å€/å¤§å°ï¼Œç”± Fate åˆ†é…

use rules/fate

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å†…å­˜æ±  â€” ä»£æ•°å½¢å¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pool {
    count: 0          # æ± æ•°é‡ï¼ˆFate å†³å®šï¼‰
    base: []          # åŸºå€åˆ—è¡¨
    size: []          # å¤§å°åˆ—è¡¨
    used: []          # ä½¿ç”¨é‡åˆ—è¡¨
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆå§‹åŒ– â€” Fate æ¢æµ‹å¹¶åˆ†é…
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.init {
    # ä» Fate è·å–å†…å­˜å¸ƒå±€
    pool.count = 0
    pool.base = []
    pool.size = []
    pool.used = []
    
    # æ³¨å†Œåˆ° Fate
    fate.register_adapter(fate.next_id(), tile.adapt)
}

fn tile.adapt {
    # Fate è°ƒç”¨ï¼šæ ¹æ®è§‚æµ‹è°ƒæ•´æ± 
    when pool.count == 0 {
        # é¦–æ¬¡ï¼šåˆ†é…ä¸€ä¸ªæ± 
        tile.add_pool()
    }
    
    # æ ¹æ®ä½¿ç”¨ç‡å†³å®šæ˜¯å¦æ‰©å±•
    ratio = tile.ratio()
    when ratio > 0.8 {
        tile.add_pool()
    }
}

fn tile.add_pool {
    # ç”± Fate å†³å®šåœ°å€å’Œå¤§å°
    id = pool.count
    pool.count = pool.count + 1
    
    # Fate åˆ†é…ï¼ˆä»£æ•°å½¢å¼ï¼‰
    pool.base <- fate.next_addr()
    pool.size <- fate.next_size()
    pool.used <- 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# åˆ†é… â€” æ ¹æ®ç»Ÿä¸€åœºå‚æ•°é€‰æ‹©æ± 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.alloc size {
    when pool.count == 0 {
        tile.add_pool()
    }
    
    # é€‰æ‹©æ± ï¼šåŸºäºç»Ÿä¸€åœº i, e, r
    idx = tile.select_pool()
    
    -> tile.alloc_from(idx, size)
}

fn tile.select_pool {
    # æ ¹æ® unified å‚æ•°é€‰æ‹©
    # i é«˜ â†’ é€‰ä½ç¼–å·æ± ï¼ˆå‹ç¼©ï¼‰
    # e é«˜ â†’ é€‰é«˜ç¼–å·æ± ï¼ˆå¿«é€Ÿï¼‰
    when unified.i > unified.e {
        -> 0
    }
    -> pool.count - 1
}

fn tile.alloc_from idx size {
    when idx >= pool.count { -> 0 }
    
    when pool.used[idx] + size > pool.size[idx] {
        tile.compact(idx)
    }
    
    addr = pool.base[idx] + pool.used[idx]
    pool.used[idx] = pool.used[idx] + size
    
    -> addr
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# é‡Šæ”¾
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.free addr size {
    idx = tile.find_pool(addr)
    when idx >= 0 {
        pool.used[idx] = pool.used[idx] - size
    }
}

fn tile.find_pool addr {
    i = 0
    loop {
        when i >= pool.count { -> -1 }
        when addr >= pool.base[i] {
            when addr < pool.base[i] + pool.size[i] {
                -> i
            }
        }
        i = i + 1
    }
    -> -1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ç´§ç¼© â€” Collapse è§¦å‘
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.compact idx {
    # Fate è¾¹é™…æ”¶ç›Šæ£€æŸ¥
    before = pool.used[idx]
    # ... æ‰§è¡Œç´§ç¼© ...
    after = pool.used[idx]
    
    gain = before - after
    observe.gain = gain
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# çŠ¶æ€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn tile.total_used {
    sum = 0
    i = 0
    loop {
        when i >= pool.count { break }
        sum = sum + pool.used[i]
        i = i + 1
    }
    -> sum
}

fn tile.total_size {
    sum = 0
    i = 0
    loop {
        when i >= pool.count { break }
        sum = sum + pool.size[i]
        i = i + 1
    }
    -> sum
}

fn tile.ratio {
    total = tile.total_size()
    when total == 0 { -> 0 }
    -> tile.total_used() / total
}

fn tile.report {
    out "[Tile] pools:"
    out pool.count
    out " used:"
    out tile.total_used()
    out "/"
    out tile.total_size()
}
