# ğŸ—„ï¸ Fate æ•°æ®åº“ â€” å®¹å™¨ + è‡ªåŠ¨ä¼˜åŒ–
# Fate ä¸»å¯¼ï¼šå¦‚ä½•å»ºç«‹å®¹å™¨ã€å¦‚ä½•ä¼˜åŒ–
# 
# è¯­æ³•ï¼š
#   db users                    # åˆ›å»ºå®¹å™¨ï¼ˆè‡ªåŠ¨é€‚é…ï¼‰
#   db cache hint="cache"       # å¸¦ hint åˆ›å»º
#   users.put("key", value)     # å­˜å…¥
#   users.get("key")            # è¯»å–
#   users.del("key")            # åˆ é™¤
#   users.query(predicate)      # æŸ¥è¯¢
#   users.count                 # è®°å½•æ•°
#   db.all                      # æ‰€æœ‰å®¹å™¨

use rules/fate
use rules/tile

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å®¹å™¨ â€” Fate åˆ›å»ºå’Œç®¡ç†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# å®¹å™¨ç»“æ„ â€” Fate å†³å®šæ‰€æœ‰å±æ€§
container -> structure {
    id -> fate.next_id()
    name -> ""
    data -> []
    importance -> 0             # Fate è¯„ä¼°
    access_pattern -> 0         # Fate å­¦ä¹ 
    optimal_pool -> 0           # Fate å†³å®š
    last_access -> 0
    access_count -> 0
    auto_adapt -> true          # é»˜è®¤è‡ªåŠ¨é€‚é…
}

# æ‰€æœ‰å®¹å™¨åˆ—è¡¨ â€” Fate ç®¡ç†
containers -> []
db.all -> containers

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å®¹å™¨åˆ›å»º â€” Fate ä¸»å¯¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å®¹å™¨åˆ›å»º â€” Fate è‡ªåŠ¨é€‚é…
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db name {
    -> db.create_named(name, "auto")
}

fn db.create {
    -> db.create_named("", "auto")
}

fn db.create_named name hint {
    c = container.new()
    c.id = fate.next_id()
    c.name = name
    c.auto_adapt = true
    
    # Fate å†³å®š
    when hint == "auto" {
        c.optimal_pool = fate.decide_pool()
        c.importance = 0.5
    }
    when hint != "auto" {
        fate.learn("hint:" + c.id, hint)
        c.optimal_pool = fate.decide_pool_for(hint)
        c.importance = fate.evaluate_hint(hint)
    }
    
    c.addr = tile.alloc_from(c.optimal_pool, 1024)
    
    containers <- c
    
    # ç»‘å®šæ–¹æ³•
    c.put = fn(k, v) { db.put(c, k, v) }
    c.get = fn(k) { -> db.get(c, k) }
    c.del = fn(k) { db.delete(c, k) }
    c.count = fn() { -> len(c.data) }
    c.clear = fn() { c.data = [] }
    
    -> c
}

fn db.create_with hint {
    -> db.create_named("", hint)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ•°æ®æ“ä½œ â€” è‡ªåŠ¨å­¦ä¹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.put c key value {
    # å­˜å…¥æ•°æ®
    c.data <- { key: key, value: value }
    
    # Fate å­¦ä¹ è®¿é—®æ¨¡å¼
    c.access_count = c.access_count + 1
    c.last_access = fate.tick_count
    fate.learn_access(c.id, "put")
    
    # è‡ªåŠ¨ä¼˜åŒ–æ£€æŸ¥
    db.auto_optimize(c)
}

fn db.get c key {
    # æŸ¥æ‰¾æ•°æ®
    i = 0
    loop {
        when i >= len(c.data) { -> 0 }
        when c.data[i].key == key {
            # æ›´æ–°è®¿é—®æ¨¡å¼
            c.access_count = c.access_count + 1
            c.last_access = fate.tick_count
            fate.learn_access(c.id, "get")
            
            -> c.data[i].value
        }
        i = i + 1
    }
    -> 0
}

fn db.delete c key {
    new_data = []
    i = 0
    loop {
        when i >= len(c.data) { break }
        when c.data[i].key != key {
            new_data <- c.data[i]
        }
        i = i + 1
    }
    c.data = new_data
    
    fate.learn_access(c.id, "delete")
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è‡ªåŠ¨ä¼˜åŒ– â€” Fate ä¸»å¯¼
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.auto_optimize c {
    # Fate è¯„ä¼°æ˜¯å¦éœ€è¦ä¼˜åŒ–
    when fate.should_optimize(c) {
        db.optimize(c)
    }
}

fn db.optimize c {
    # 1. é‡æ–°è¯„ä¼°é‡è¦æ€§
    c.importance = fate.evaluate_container(c)
    
    # 2. æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»æ± 
    new_pool = fate.decide_pool_for_pattern(c.access_pattern)
    when new_pool != c.optimal_pool {
        db.migrate(c, new_pool)
    }
    
    # 3. æ•°æ®å‹ç¼©ï¼ˆå¦‚æœ Fate è®¤ä¸ºéœ€è¦ï¼‰
    when fate.should_compact(c) {
        db.compact(c)
    }
}

fn db.migrate c new_pool {
    # è¿ç§»å®¹å™¨åˆ°æ–°æ± 
    old_addr = c.addr
    c.addr = tile.alloc_from(new_pool, len(c.data) * 64)
    tile.free(old_addr, 1024)
    c.optimal_pool = new_pool
    
    fate.learn("migrate:" + c.id, new_pool)
}

fn db.compact c {
    # Collapse é£æ ¼å‹ç¼©
    # ç§»é™¤é‡å¤ã€åˆå¹¶ç›¸ä¼¼
    fate.learn("compact:" + c.id, len(c.data))
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Fate å†³ç­–å‡½æ•°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn fate.decide_pool {
    # åŸºäºå½“å‰ç»Ÿä¸€åœºå‚æ•°
    when field.i > 0.7 { -> 0 }  # é«˜å¯†åº¦ â†’ å‹ç¼©æ± 
    when field.r > 0.7 { -> 1 }  # é«˜å…³è” â†’ æ¨¡å¼æ± 
    when field.e > 0.5 { -> 3 }  # é«˜ç†µ â†’ å¿«é€Ÿæ± 
    -> 2                          # é»˜è®¤ â†’ é€šç”¨æ± 
}

fn fate.decide_pool_for hint {
    # æ ¹æ® hint å†³å®š
    when hint == "cache" { -> 0 }
    when hint == "index" { -> 1 }
    when hint == "temp" { -> 3 }
    -> fate.decide_pool()
}

fn fate.decide_pool_for_pattern pattern {
    # æ ¹æ®è®¿é—®æ¨¡å¼å†³å®š
    # é¢‘ç¹è¯» â†’ å‹ç¼©æ± 
    # é¢‘ç¹å†™ â†’ å¿«é€Ÿæ± 
    # æ··åˆ â†’ é€šç”¨æ± 
    when pattern > 100 { -> 0 }
    when pattern < 10 { -> 3 }
    -> 2
}

fn fate.evaluate_hint hint {
    when hint == "cache" { -> 0.8 }
    when hint == "index" { -> 0.9 }
    when hint == "temp" { -> 0.2 }
    -> 0.5
}

fn fate.evaluate_container c {
    # åŸºäºè®¿é—®é¢‘ç‡å’Œæ•°æ®é‡
    score = 0.5
    when c.access_count > 100 { score = score + 0.2 }
    when len(c.data) > 50 { score = score + 0.1 }
    when fate.tick_count - c.last_access < 100 { score = score + 0.1 }
    -> score
}

fn fate.should_optimize c {
    # æ¯ 50 æ¬¡è®¿é—®ä¼˜åŒ–ä¸€æ¬¡
    -> c.access_count % 50 == 0
}

fn fate.should_compact c {
    -> len(c.data) > 100
}

fn fate.learn_access id op {
    key = "access:" + id
    count = fate.recall(key)
    fate.learn(key, count + 1)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æŸ¥è¯¢ â€” Fate ä¼˜åŒ–çš„æŸ¥æ‰¾
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.query predicate {
    # è·¨æ‰€æœ‰å®¹å™¨æŸ¥è¯¢
    results = []
    i = 0
    loop {
        when i >= len(containers) { break }
        c = containers[i]
        
        j = 0
        loop {
            when j >= len(c.data) { break }
            when predicate(c.data[j]) {
                results <- c.data[j]
            }
            j = j + 1
        }
        
        i = i + 1
    }
    -> results
}

fn db.find_by_key key {
    # æŸ¥æ‰¾æ‰€æœ‰å®¹å™¨ä¸­çš„ key
    i = 0
    loop {
        when i >= len(containers) { -> 0 }
        result = db.get(containers[i], key)
        when result { -> result }
        i = i + 1
    }
    -> 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GC â€” Fate å†³å®šé‡Šæ”¾
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.gc {
    # Fate è¯„ä¼°å¹¶é‡Šæ”¾ä¸é‡è¦çš„å®¹å™¨
    new_containers = []
    i = 0
    loop {
        when i >= len(containers) { break }
        c = containers[i]
        
        # Fate è¯„ä¼°
        importance = fate.evaluate_container(c)
        
        when importance > 0.3 {
            new_containers <- c
        }
        when importance <= 0.3 {
            # é‡Šæ”¾
            tile.free(c.addr, 1024)
            fate.learn("gc:" + c.id, importance)
        }
        
        i = i + 1
    }
    containers = new_containers
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ³¨å†Œåˆ° Fate
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.init {
    containers = []
    fate.register_adapter(fate.next_id(), db.adapt)
}

fn db.adapt {
    # Fate è§¦å‘çš„è‡ªåŠ¨ç»´æŠ¤
    
    # GCï¼ˆå¦‚æœå®¹å™¨å¤ªå¤šï¼‰
    when len(containers) > 100 {
        db.gc()
    }
    
    # å…¨å±€ä¼˜åŒ–ï¼ˆå¦‚æœ Fate è®¤ä¸ºéœ€è¦ï¼‰
    when fate.should_global_optimize() {
        db.global_optimize()
    }
}

fn db.global_optimize {
    i = 0
    loop {
        when i >= len(containers) { break }
        db.optimize(containers[i])
        i = i + 1
    }
}

fn fate.should_global_optimize {
    -> observe.usage > 0.8
}

fn db.report {
    out "[DB] containers:"
    out len(containers)
    
    total = 0
    i = 0
    loop {
        when i >= len(containers) { break }
        total = total + len(containers[i].data)
        i = i + 1
    }
    out " records:"
    out total
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ€§èƒ½åŸºå‡†
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn db.bench count {
    out "[Bench] å¼€å§‹æ€§èƒ½æµ‹è¯•..."
    
    # åˆ›å»ºæµ‹è¯•å®¹å™¨
    c = db("bench")
    
    # å†™å…¥æµ‹è¯•
    start = fate.tick_count
    i = 0
    loop {
        when i >= count { break }
        db.put(c, "key" + i, { value: i })
        i = i + 1
    }
    write_time = fate.tick_count - start
    
    # è¯»å–æµ‹è¯•
    start = fate.tick_count
    i = 0
    loop {
        when i >= count { break }
        db.get(c, "key" + i)
        i = i + 1
    }
    read_time = fate.tick_count - start
    
    # ä¼˜åŒ–æµ‹è¯•
    start = fate.tick_count
    db.optimize(c)
    opt_time = fate.tick_count - start
    
    out "[Bench] å†™å…¥ "
    out count
    out " æ¡: "
    out write_time
    out " ticks"
    
    out "[Bench] è¯»å– "
    out count
    out " æ¡: "
    out read_time
    out " ticks"
    
    out "[Bench] ä¼˜åŒ–: "
    out opt_time
    out " ticks"
    
    out "[Bench] è‡ªåŠ¨é€‚é…æ¬¡æ•°: "
    out c.access_count / 50
    
    -> { write: write_time, read: read_time, optimize: opt_time }
}
