# ğŸŒŠ Wave ä»£ç ç”Ÿæˆ
# æ— é¢„è®¾ï¼Œç”± Fate/å¹³å°æä¾›

use rules/fate
use platform/kernel

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å¯„å­˜å™¨ â€” ä»£æ•°ç¼–å·
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

reg {
    a: 0    # ç´¯åŠ å™¨
    c: 1    # è®¡æ•°å™¨
    d: 2    # æ•°æ®
    b: 3    # åŸºå€
    sp: 4   # æ ˆæŒ‡é’ˆ
    bp: 5   # åŸºå€æŒ‡é’ˆ
    si: 6   # æºç´¢å¼•
    di: 7   # ç›®æ ‡ç´¢å¼•
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ç¼–è¯‘å‰å¯¼/åç¼€ â€” å¹³å°ç”± env æä¾›
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn codegen.prologue {
    # è¾“å‡ºå¹³å°å¤´éƒ¨ï¼ˆELF/Mach-O/PE/WAVEï¼‰
    platform.emit_header()
    
    # æ ˆå¸§è®¾ç½®
    gen.push(reg.bp)
    gen.mov_r_r(reg.bp, reg.sp)
    gen.sub_r_imm8(reg.sp, 0x20)
}

fn codegen.exit code {
    # ç³»ç»Ÿè°ƒç”¨ exit
    gen.mov_r64_imm(reg.a, platform.syscall_base + 60)  # exit syscall
    gen.mov_r64_imm(reg.di, code)
    gen.syscall()
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æŒ‡ä»¤ç”Ÿæˆ â€” å¹³å°æ— å…³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn gen.push r {
    emit 0x50 + r
}

fn gen.pop r {
    emit 0x58 + r
}

fn gen.mov_r64_imm r imm {
    emit 0x48
    emit 0xb8 + r
    emit imm  # 8 bytes
}

fn gen.mov_r_r dst src {
    emit 0x48
    emit 0x89
    emit 0xc0 + src * 8 + dst
}

fn gen.sub_r_imm8 r imm8 {
    emit 0x48
    emit 0x83
    emit 0xe8 + r
    emit imm8
}

fn gen.syscall {
    emit 0x0f
    emit 0x05
}

fn gen.ret {
    emit 0xc3
}

fn gen.jmp offset {
    emit 0xe9
    emit offset
}

fn gen.jz offset {
    emit 0x0f
    emit 0x84
    emit offset
}

fn gen.jnz offset {
    emit 0x0f
    emit 0x85
    emit offset
}

fn gen.call offset {
    emit 0xe8
    emit offset
}

fn gen.test r1 r2 {
    emit 0x48
    emit 0x85
    emit 0xc0 + r1 * 8 + r2
}

fn gen.pause {
    emit 0xf3
    emit 0x90
}

fn gen.rdtsc {
    emit 0x0f
    emit 0x31
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# è§„åˆ™æ˜ å°„ â€” æœºå™¨ç 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn codegen.prologue {
    gen.push(reg.bp)
    gen.mov_r_r(reg.bp, reg.sp)
    gen.sub_r_imm8(reg.sp, 64)
}

fn codegen.epilogue {
    gen.mov_r_r(reg.sp, reg.bp)
    gen.pop(reg.bp)
    gen.ret()
}

# è¾“å‡º â€” é€šè¿‡å¹³å° syscall
fn codegen.write addr len {
    platform.syscall(1, 1, addr, len)  # write(1, addr, len)
}

# é€€å‡º â€” é€šè¿‡å¹³å° syscall
fn codegen.exit code {
    platform.syscall(60, code, 0, 0)   # exit(code)
}

fn codegen.infinite_loop {
    emit 0xe9
    emit 0xfb
    emit 0xff
    emit 0xff
    emit 0xff
}

fn codegen.event_loop {
    gen.pause()
    emit 0xeb
    emit 0xfc
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ„å›¾ç¼–è¯‘
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compile.out text {
    addr = data.add_string(text)
    len = text.length + 1
    codegen.write(addr, len)
}

fn compile.emit bytes {
    emit bytes
}

fn compile.fn name body {
    label.add(name)
    codegen.prologue()
    compile(body)
    codegen.epilogue()
}

fn compile.loop body {
    start = label.current()
    compile(body)
    gen.jmp(start - label.current() - 5)
}

fn compile.keep {
    codegen.event_loop()
}

fn compile.exit code {
    codegen.exit(code)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# å®Œæ•´è¯­æ³•ç¼–è¯‘
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compile.when cond body {
    # æ¡ä»¶è·³è½¬
    codegen.check_condition(cond)
    compile(body)
}

fn compile.otherwise body {
    # else åˆ†æ”¯
    compile(body)
}

fn compile.assign name value {
    # å˜é‡èµ‹å€¼
    addr = data.add_variable(name)
    codegen.store(addr, value)
}

fn compile.call name args {
    # å‡½æ•°è°ƒç”¨
    addr = label.get(name)
    gen.call(addr)
}

fn compile.pipeline from to {
    # Pipeline: from -> to
    # Fate ç®¡ç†æ‰§è¡Œ
    result = from
    when to.type == "pipeline" {
        result = compile.pipeline(result, to.from)
        result = compile.pipeline(result, to.to)
    }
    when to.type != "pipeline" {
        # è°ƒç”¨ to(result)
        compile.call(to, [result])
    }
    -> result
}

fn compile.limit n {
    gen.mov_r64_imm(reg.a, n)
    fate.set_limit(n)
}

fn compile.fate_enable {
    gen.mov_r64_imm(reg.a, 1)
    fate.enable()
}

fn compile.fate_disable {
    gen.mov_r64_imm(reg.a, 0)
    fate.disable()
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# æ•°æ®åº“ç¼–è¯‘ â€” Fate è‡ªåŠ¨é€‚é…
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn compile.db_create name {
    # è°ƒç”¨ db.create_named(name, "auto")
    # ç”Ÿæˆè°ƒç”¨ä»£ç 
    db.create_named(name, "auto")
}

fn compile.db_put c k v {
    db.put(c, k, v)
}

fn compile.db_get c k {
    -> db.get(c, k)
}

fn compile.db_bench n {
    db.bench(n)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Fate é’©å­ â€” åŠ¨æ€æ¨¡å¼æ—¶æ’å…¥
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn codegen.check_fate {
    # ä» Fate çŠ¶æ€åœ°å€è¯»å–
    fate_addr = fate.recall("addr:state")
    emit 0x48
    emit 0xa1
    emit fate_addr
    gen.test(reg.a, reg.a)
}

fn codegen.measure_begin {
    gen.rdtsc()
    time_addr = fate.recall("addr:time")
    emit 0x48
    emit 0xa3
    emit time_addr
}

fn codegen.measure_end {
    gen.rdtsc()
    time_addr = fate.recall("addr:time")
    emit 0x48
    emit 0x2b
    emit 0x04
    emit 0x25
    emit time_addr
}

fn codegen.loop_with_fate body {
    start = label.current()
    
    codegen.check_fate()
    gen.jz(8)  # è·³è¿‡æµ‹é‡
    
    codegen.measure_begin()
    
    compile(body)
    
    codegen.check_fate()
    gen.jz(8)  # è·³è¿‡æ£€æŸ¥
    
    codegen.measure_end()
    
    gen.jmp(start - label.current() - 5)
}

fn codegen.call_with_fate addr {
    codegen.check_fate()
    gen.jz(16)
    
    codegen.measure_begin()
    gen.call(addr)
    codegen.measure_end()
    gen.jmp(8)
    
    gen.call(addr)
}
